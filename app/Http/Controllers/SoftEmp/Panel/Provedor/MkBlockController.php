<?php

namespace App\Http\Controllers\SoftEmp\Panel\Provedor;

use App\Http\Controllers\SoftEmp\Panel\CrudController;
use App\Models\Provedor\MkAuth\Client;
use App\Models\Provedor\MkAuth\Radius\Nas;
use App\Models\Provedor\MkBlock;
use Illuminate\Http\Request;
use Mikrotik\Api\MikrotikAPI;

class MkBlockController extends CrudController
{
    private $pathImg = 'storage/softemp/panel/uploads/sobre/';

    protected $pathView = 'softemp.panel.provedor.mkblock';
    protected $groupRoute = 'softemp.panel.provedor.mkblock';
    private $mkAuthClient;
    private $nas;
    private $arrayLog = [];

    public function __construct(MkBlock $model, Request $request, Client $client, Nas $nas)
    {
        parent::__construct($model, $request, $this->groupRoute, $this->pathView);

        $this->mkAuthClient = $client;
        $this->nas = $nas;
    }

    public function index()
    {
        return parent::index(); // TODO: Change the autogenerated stub
    }

    public function getMkBlock()
    {


    }

    public function rbConnection($host)
    {
        $rb_login = 'floripaserver';
        $rb_password = 'j5/t30/p';

        return new MikrotikAPI($host, $rb_login, $rb_password);
    }

    public function sincLoginBlock()
    {
        $arrayMKAuthBloqueados = [];
        $arrayRbBloqueados = [];

        foreach ($this->nas->getNas() as $rb) {
            //$this->arrayLog[] = date('Y-m-d H:i:s').' - entrando na RB - '.$rb->nasname;//adicionando ao log
            $this->setLog('Acessando '.$rb->shortname.' - IP - '.$rb->nasname);

            // buscando os cliente bloqueados no MkAuth
            $mkAuthBloqueados = $this->getMkAuthBloquedos($rb->nasname);

            // conenctando na RB pelo IP cadastrado no menu servidores no MkAuth
            $rbConn = $this->rbConnection($rb->nasname);

            // verifica o status da conexÃ£o com os roteadores
            if($rbConn->statusConnect() === true){

                $objAddressList = $rbConn->ip()->firewall()->addressList();

                $rbBloqueados = $this->getRbBloqueados($objAddressList);

                $this->deleteAddressList($objAddressList,$rbBloqueados);

                $this->addBloqueioAddressList($objAddressList,$mkAuthBloqueados);

                $arrayRbBloqueados[$rb->nasname] = $rbBloqueados;

                //print_r('conectou = '.$rb->nasname);
            } else {
                $result = date('Y-m-d H:i:s').'-'.$rbConn->statusConnect() .' ao Nas: '.$rb->shortname.' no IP: '.$rb->nasname;
                $arrayRbBloqueados[$rb->nasname] = $result;
                //print_r($rbConn->statusConnect() .' = '.$rb->nasname);

                $this->arrayLog[] = $result;
            }

            $arrayMKAuthBloqueados[$rb->nasname] = $mkAuthBloqueados;
        }
       // $this->setLog($this->arrayLog);
        dd($arrayMKAuthBloqueados, $arrayRbBloqueados);
    }

    /**
     * buscando os clientes bloqueados no MkAuth
     *
     * @param $ramal
     * @return array
     */
    private function getMkAuthBloquedos($ramal)
    {
        $query = $this->mkAuthClient->newModelQuery();
        $query->select(['nome', 'login', 'ip', 'ramal']);
        $query->where('cli_ativado', 's');
        $query->whereBloqueado('sim');
        $query->where('ramal', $ramal);
        return $query->get()->toArray();
    }

    /**
     * retorna os logins bloqueados pelo MkAuth nas RBs
     *
     * @param $objAddressList
     * @return mixed
     */
    private function getRbBloqueados($objAddressList)
    {
        $bloqueados = $objAddressList->where('list', 'pgcorte');

        return $bloqueados;
    }

    /**
     * @param $objAddressList
     * @param $bloqueados
     */
    private function deleteAddressList($objAddressList, $bloqueados){
        foreach ($bloqueados as $bloqueado) {
            if (is_array($bloqueado)) {
                $objAddressList->delete($bloqueado['.id']);
//                $this->arrayLog[] = date('Y-m-d H:i:s').' - removendo o bloqueio - '.$bloqueado['comment'].' IP: '.$bloqueado['address'];//adicionando ao log
                $this->setLog('removendo o bloqueio - '.$bloqueado['comment'].' IP: '.$bloqueado['address']);
            }
        }
    }

    /**
     * @param $objAddressList
     * @param $mkAuthBloqueados
     */
    private function addBloqueioAddressList($objAddressList, $mkAuthBloqueados){
        foreach ($mkAuthBloqueados as $mkAuthBloqueado) {
            if (is_array($mkAuthBloqueado)) {
                $params = [
                    'list' => 'pgcorte',
                    'address' => $mkAuthBloqueado['ip'],
                    'comment' => 'ssh_corte_' . $mkAuthBloqueado['login']
                ];
                $objAddressList->add($params);
//                $this->arrayLog[] = date('Y-m-d H:i:s').' - adicionando bloqueio - '.$mkAuthBloqueado['login'].' IP: '.$mkAuthBloqueado['ip'];//adicionando ao log
                $this->setLog('adicionando bloqueio - '.$mkAuthBloqueado['login'].' IP: '.$mkAuthBloqueado['ip']);
            }
        }
    }

    /**
     * metodo para adicioanr registros ao log
     *
     * @param $params
     */
    private function setLog($params){
        if(is_array($params)){
            foreach ($params as $param){
                exec("echo $param >> log-mkblock.log");//adicionando ao log
            }
        }else {
            $log = date('Y-m-d H:i:s').' - '.$params;//adicionando ao log
            exec("echo $log >> log-mkblock.log");
        }
    }
}
